#version 450
#extension GL_KHR_shader_subgroup_arithmetic : require

layout (local_size_x = 8, local_size_y = 4, local_size_z = 1) in;
layout (binding = 0, r32f) uniform readonly image2D gBufferDepth;
layout (binding = 1, rgba16f) uniform readonly image2D nasDataSurface;
layout (binding = 2, r32ui) uniform uimage2D vrsSurface;
layout (binding = 3) uniform AdaptiveShadingConstants 
{
	mat4 reprojectionMatrix;
    vec2 previousViewOrigin;
    vec2 previousViewSize;
    vec2 sourceTextureSizeInv;
    float errorSensitivity;
    float motionSensitivity;
} ShadingRatePassParams;

#define TILE_SIZE 16

shared uint groupMinDepth;


//SV_DispatchThreadID -> gl_GlobalInvocationID
//SV_GroupThreadID -> gl_LocalInvocationID
//SV_GroupID -> gl_WorkGroupID

void main()
{	
    // uint screenWidth, screenHeight;
    // screenWidth = textureSize(gBufferDepth,0).x;
    // screenHeight = textureSize(gBufferDepth,0).y;

    if(gl_LocalInvocationID.x==0&&gl_LocalInvocationID.y==0)
    {
        groupMinDepth = floatBitsToUint(1.0f);
    }

    groupMemoryBarrier();

    uvec2 localID = gl_LocalInvocationID.xy;
    localID.x <<= 1;
    localID.y <<= 2;

    uvec2 tileOffset = gl_WorkGroupID.xy;
    tileOffset.x <<= 4;
    tileOffset.y <<= 4;

    ivec2 blockBaseCoord = ivec2(tileOffset + localID);

    vec4 depth;
    depth.x = imageLoad(gBufferDepth, ivec2(blockBaseCoord.x, blockBaseCoord.y)+ivec2(0,0)).r;
    depth.y = imageLoad(gBufferDepth, ivec2(blockBaseCoord.x, blockBaseCoord.y)+ivec2(1,1)).r;
    depth.z = imageLoad(gBufferDepth, ivec2(blockBaseCoord.x, blockBaseCoord.y)+ivec2(0,2)).r;
    depth.w = imageLoad(gBufferDepth, ivec2(blockBaseCoord.x, blockBaseCoord.y)+ivec2(1,3)).r;

    depth.xy = min(depth.xy, depth.zw);
    depth.x = min(depth.x, depth.y);
    atomicMin(groupMinDepth, floatBitsToUint(depth.x));

    groupMemoryBarrier();

    if(gl_LocalInvocationID.x==0&&gl_LocalInvocationID.y==0)
    {
        vec2 currWindowPos = (gl_WorkGroupID.xy + 0.5) * TILE_SIZE;
        vec2 currUv = currWindowPos * ShadingRatePassParams.sourceTextureSizeInv;

        vec4 clipPos;
        clipPos.x = currUv.x * 2 - 1;
        clipPos.y = 1 - currUv.y * 2;
        clipPos.z = uintBitsToFloat(groupMinDepth);
        clipPos.w = 1;

        vec2 mVec = vec2(0, 0);
        vec4 prevClipPos = clipPos * ShadingRatePassParams.reprojectionMatrix;

        vec2 prevWindowPos = currWindowPos;

        if (prevClipPos.w > 0)
        {
            prevClipPos.xyz /= prevClipPos.w;
            vec2 prevUV;
            prevUV.x = 0.5 + prevClipPos.x * 0.5;
            prevUV.y = 0.5 - prevClipPos.y * 0.5;

            prevWindowPos = prevUV * ShadingRatePassParams.previousViewSize + ShadingRatePassParams.previousViewOrigin;
            mVec = prevWindowPos.xy - currWindowPos.xy;
        }

        mVec = abs(mVec) * ShadingRatePassParams.motionSensitivity;

        vec2 bhv = pow(1.0 / (1 + pow(1.05 * mVec, vec2(3.1))), vec2(0.35));
        vec2 bqv = 2.13 * pow(1.0 / (1 + pow(0.55 * mVec, vec2(2.41))), vec2(0.49));

        vec2 diff = imageLoad(nasDataSurface, ivec2(prevWindowPos * ShadingRatePassParams.sourceTextureSizeInv)).rg;
        vec2 diff2 = diff * bhv;
        vec2 diff4 = diff * bqv;

        float threshold = ShadingRatePassParams.errorSensitivity;

        uint ShadingRate = 0;
        uint rate = 5;
        ShadingRate |= ((diff2.x >= threshold) ? 0 : ((diff4.x > threshold) ? 0x4 : 0x8));
        ShadingRate |= ((diff2.y >= threshold) ? 0 : ((diff4.y > threshold) ? 0x1 : 0x2));

        // Disable 4x4 shading rate (low quality, limited perf gain)
        if (ShadingRate == 0xa)
        {
            ShadingRate = (diff2.x > diff2.y) ? 0x6 : 0x9; // use 2x4 or 4x2 based on directional gradient
        }
        // Disable 4x1 or 1x4 shading rate (unsupported)
        else if (ShadingRate == 0x8)
        {
            ShadingRate = 0x4;
        }
        else if (ShadingRate == 0x2)
        {
            ShadingRate = 0x1;
        }


        if(ShadingRate == 0)
        {
            rate = 5;
        }
        else if(ShadingRate == 0x1)
        {
            rate = 7;
        }
        else if(ShadingRate == 0x4)
        {
            rate = 6;
        }
        else if(ShadingRate == 0x5)
        {
            rate = 8;
        }
        else if(ShadingRate == 0x6)
        {
            rate = 10;
        }
        else if(ShadingRate == 0x9)
        {
            rate = 9;
        }

        imageStore(vrsSurface, ivec2(gl_WorkGroupID.xy), uvec4(rate,0,0,0));
    }
}